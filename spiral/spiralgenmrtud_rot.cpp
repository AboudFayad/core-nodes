/*     The GPI core node library is licensed under
 * either the BSD 3-clause or the LGPL v. 3.
 * 
 *     Under either license, the following additional term applies:
 * 
 *         NO CLINICAL USE.  THE SOFTWARE IS NOT INTENDED FOR COMMERCIAL
 * PURPOSES AND SHOULD BE USED ONLY FOR NON-COMMERCIAL RESEARCH PURPOSES.  THE
 * SOFTWARE MAY NOT IN ANY EVENT BE USED FOR ANY CLINICAL OR DIAGNOSTIC
 * PURPOSES.  YOU ACKNOWLEDGE AND AGREE THAT THE SOFTWARE IS NOT INTENDED FOR
 * USE IN ANY HIGH RISK OR STRICT LIABILITY ACTIVITY, INCLUDING BUT NOT LIMITED
 * TO LIFE SUPPORT OR EMERGENCY MEDICAL OPERATIONS OR USES.  LICENSOR MAKES NO
 * WARRANTY AND HAS NOR LIABILITY ARISING FROM ANY USE OF THE SOFTWARE IN ANY
 * HIGH RISK OR STRICT LIABILITY ACTIVITIES.
 * 
 *     If you elect to license the GPI core node library under the LGPL the
 * following applies:
 * 
 *         This file is part of the GPI core node library.
 * 
 *         The GPI core node library is free software: you can redistribute it
 * and/or modify it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 3 of the License,
 * or (at your option) any later version. GPI core node library is distributed
 * in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Lesser General Public License for more details.
 * 
 *         You should have received a copy of the GNU Lesser General Public
 * License along with the GPI core node library. If not, see
 * <http://www.gnu.org/licenses/>.
 */


/* spiralrot.c
 *
 * Author: Jim Pipe
 * Date: 2020 oct
 * Brief: takes coords generated by xxspiralgen.c and rotates them to their final
 *          orientations. 
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>

/* the base spiral sequence */

#ifndef MAX
#define UNDEFMAX
#define MAX(a,b) (((a)<(b))?(b):(a))
#endif

#ifndef MIN
#define UNDEFMIN
#define MIN(a,b) (((a)>(b))?(b):(a))
#endif

void spiralrot(Array<float> &arm0, Array<double> &ktmp,
                  Array<double> &karray, double xdel, double ydel,
                  double dwell)
{

    uint64_t i, j;
    double betastep, beta, cb, sb;

    double ix,iy;
    int fix, fiy;
    int ix1, ix2, ix3, ix4;
    int iy1, iy2, iy3, iy4;
    double delx, dely;
    double delxn, delyn;
    double delx_sq, dely_sq;
    double delxn_sq, delyn_sq;
    double a0,a1,a2, q1, q2;
    double f1,f2,f3,f4;

    betastep = -2.*M_PI/(double)(ktmp.size(2)); //DHW match psd add -      
    for(j=0;j<ktmp.size(2);j++) { 
      // arms
      beta = (double)(j)*betastep;
      cb = cos(beta);
      sb = sin(beta);
      for(i=0;i<ktmp.size(1);i++) {
        // points
        ktmp(0,i,j) = cb*arm0(0,i) - sb*arm0(1,i);
        ktmp(1,i,j) = cb*arm0(1,i) + sb*arm0(0,i);
        } // i
      } // j

    //*************************************************************************************
    // interpolate ktmp to kout 
    //*************************************************************************************
    // For interpoloating along kx:
    // We first find ix where kout(i,...) = ktmp(ix,....).
    // ix is a real number between ix2 = floor(ix) and ix3 = ceiling (ix)
    // and delx = ix - ix2, i.e.
    //
    //                  delx
    //                |<---->|
    //    *           *      O    *           *
    //   ix1         ix2     ix  ix3         ix4
    //
    // Now if
    // f1 = ktmp(ix1,...)
    // f2 = ktmp(ix2,...)
    // f3 = ktmp(ix3,...)
    // f4 = ktmp(ix4,...)
    //
    // We do a simple quadratic interpolation based on f1, f2, and f3, i.e.
    
    // f(ix) = 0.5*(f1+f3-2f2)*delx^2 + 0.5*(f3-f1)*delx + f2;
    
    // and another similar quadratic interopolation based on f2, f3, and f4.
    // We then do a linear fit between these two quadratic equations based on the distance between f2 and f3. 
    // This average a function of f1, f2, f3, and f4.  (simple math :-)
    // This interpolation has the nice feature that it passes exactly through f2 and f3
    // and has continuous smooth 1st derivative
    
    // for interpolating along ky and kz, do the same (but with iy1, iz1, etc.)

    int64_t maxpt = ktmp.size(1)-1; //DHW
    float divdwell = 1./dwell;
    for(i=0;i<karray.size(1);i++) {
      // points
      // Note these times are in usec
      ix = (((double)(i)*dwell)-xdel)*divdwell;
      iy = (((double)(i)*dwell)-ydel)*divdwell;

      fix = floor(ix);
      fiy = floor(iy);

      ix1 = MIN(maxpt,MAX(0,fix - 1));
      ix2 = MIN(maxpt,MAX(0,fix));
      ix3 = MIN(maxpt,MAX(0,fix + 1));
      ix4 = MIN(maxpt,MAX(0,fix + 2));
      delx = MIN(1.,MAX(0.,ix-(double)(ix2)));
      delx_sq = delx*delx;
      delxn = MIN(1.,MAX(0.,(double)(ix3)-ix));
      delxn_sq = delxn*delxn;

      iy1 = MIN(maxpt,MAX(0,fiy - 1));
      iy2 = MIN(maxpt,MAX(0,fiy));
      iy3 = MIN(maxpt,MAX(0,fiy + 1));
      iy4 = MIN(maxpt,MAX(0,fiy + 2));
      dely = MIN(1.,MAX(0.,iy-(double)(iy2)));
      dely_sq = dely*dely;
      delyn = MIN(1.,MAX(0.,(double)(iy3)-iy));
      delyn_sq = delyn*delyn;

      for(j=0;j<karray.size(2);j++) { 
        // arms
        // X     first
        f1 = ktmp(0,ix1,j);
        f2 = ktmp(0,ix2,j);
        f3 = ktmp(0,ix3,j);
        f4 = ktmp(0,ix4,j);
        // Solve the first quadratic (f1, f2, f3)
        a2 = 0.5*(f1-2.*f2+f3);
        a1 = 0.5*(f3 - f1);
        a0 = f2;
        q1 = a2*delx_sq + a1*delx + a0;
        // Solve the second quadratic (f4, f3, f2)
        a2 = 0.5*(f4-2.*f3+f2);
        a1 = 0.5*(f2 - f4);
        a0 = f3;
        q2 = a2*delxn_sq + a1*delxn + a0;
        karray(0,i,j) = (1.-delx)*q1 + delx*q2;

        // Y     second
        f1 = ktmp(1,iy1,j);
        f2 = ktmp(1,iy2,j);
        f3 = ktmp(1,iy3,j);
        f4 = ktmp(1,iy4,j);
        // Solve the first quadratic (f1, f2, f3)
        a2 = 0.5*(f1-2.*f2+f3);
        a1 = 0.5*(f3 - f1);
        a0 = f2;
        q1 = a2*dely_sq + a1*dely + a0;
        // Solve the second quadratic (f4, f3, f2)
        a2 = 0.5*(f4-2.*f3+f2);
        a1 = 0.5*(f2 - f4);
        a0 = f3;
        q2 = a2*delyn_sq + a1*delyn + a0;
        karray(1,i,j) = (1.-dely)*q1 + dely*q2;
        } // j
      } // i

    } // spiralrot


/* undo common macro names */
#ifdef UNDEFMAX
#undef MAX
#endif

#ifdef UNDEFMIN
#undef MIN
#endif
